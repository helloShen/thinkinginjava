---
layout: post
num: 10
title: Exercise 10
chapter: Chapter 17
description: >
  (7) Using a LinkedList as your underlying implementation, define your own SortedSet.
---



#### Exercise10.java




```java


package com.ciaoshen.thinkinjava.newchapter17;
import java.util.*;

public class Exercise10 {
    // in this version we must have a Comparator<? super E>
    public static class LinkedSortedSet<E> extends AbstractSet<E> implements SortedSet<E> {
        private LinkedList<E> data = new LinkedList<E>();
        private Comparator<? super E> comparator = null;
        public LinkedSortedSet(Comparator<? super E> c) {
            comparator = c;
        }
        public LinkedSortedSet(List<E> list, Comparator<? super E> c) {
            comparator = c;
            addAll(list);
        }

        /**
         * implements Set interface
         */
        public Iterator<E> iterator() { // abstract, must implement
            return data.iterator();
        }
        public int size() { // abstract, mush implement
            return data.size();
        }
        @SuppressWarnings("unchecked")
        public boolean equals(Object o) { // take order into account
            if (o == this) {
                return true;
            }
            if (!(o instanceof Collection)) {
                return false;
            }
            Collection<E> anotherSet = (Collection<E>)o;
            if (anotherSet.size() != size()) {
                return false;
            }
            return containsAll(anotherSet);
        }
        public int hashCode() { // take order into account
            int code = 31;
            int index = 1;
            for (E ele : this) {
                code = code + ele.hashCode()*(index++);
            }
            return code;
        }

        @SuppressWarnings("unchecked")
        public boolean contains(Object o) { // more efficiently
            boolean result = false;
            E e = (E)o; // ClassCastException
            for (E ele : this) {
                if (comparator.compare(e,ele) > 0) { // 小于e，continue
                    continue;
                }
                if (comparator.compare(e,ele) == 0) { // 等于e, true, break
                    result = true;
                    break;
                }
                if (comparator.compare(e,ele) < 0) { // 大于e, break
                    break;
                }
            }
            return result;
        }

        /**
         * modification realized based on LinkedList
         */
        public boolean add(E e) {
            boolean result = data.add(e);
            data.sort(comparator);
            return result;
        }
        public boolean addAll(Collection<? extends E> c) {
            boolean result = data.addAll(c);
            data.sort(comparator);
            return result;
        }
        public void clear() {
            data.clear();
        }
        public boolean remove(Object o) {
            return data.remove(o);
        }
        public boolean removeAll(Collection<?> c) {
            return data.removeAll(c);
        }
        public boolean retainAll(Collection<?> c) {
            return data.retainAll(c);
        }

        /**
         * implements SortedSet interface
         */
        public Comparator<? super E> comparator() {
            return comparator;
        }
        public E first() {
            return data.getFirst();
        }
        public E last() {
            return data.getLast();
        }
        public SortedSet<E> headSet(E toElement) { // return the copy but not the view
            if (! contains(toElement)) {
                return null;
            }
            return subSet(first(),toElement);
        }
        public SortedSet<E> tailSet(E fromElement) { // return the copy but not the view
            if (! contains(fromElement)) {
                return null;
            }
            return subSet(fromElement,last());
        }
        public SortedSet<E> subSet(E fromElement, E toElement) { // return the copy but not the view
            if (! contains(fromElement) || ! contains(toElement)) {
                return null;
            }
            int fromIndex = data.indexOf(fromElement);
            int toIndex = data.indexOf(toElement);
            List<E> sublist = data.subList(fromIndex,toIndex);
            return new LinkedSortedSet<E>(sublist,comparator);
        }
    }
    public static void main(String[] args) {
        // constructor, iterator, size, contains, containsAll, equals
        Generator<String> strGen = new RandomGenerator.String();
        List<String> data = new ArrayList<>();
        int size = 10;
        for (int i = 0; i < size; i++) {
            data.add(strGen.next());
        }
        System.out.println("Data Source: " + data);
        LinkedSortedSet<String> mySet1 = new LinkedSortedSet<>(data, String.CASE_INSENSITIVE_ORDER);
        LinkedSortedSet<String> mySet2 = new LinkedSortedSet<>(data, String.CASE_INSENSITIVE_ORDER);
        System.out.println("My set 1: " + mySet1 + " Size: " + mySet1.size());
        System.out.println("My set 2: " + mySet2 + " Size: " + mySet2.size());
        System.out.println("My set 1 contains " + mySet1.first() + " : " + mySet1.contains(mySet1.first()));
        System.out.println("My set 1 contains \" hello \": " + mySet1.contains("hello"));
        System.out.println("Set 1 equals Set 2 ? " + mySet1.equals(mySet2));
        SortedSet<String> subset = mySet1.subSet(data.get(1),data.get(5));
        SortedSet<String> subset2 = mySet1.headSet(data.get(8));
        System.out.println("SubSet of Set1: " + subset);
        System.out.println("SubSet2 of Set1: " + subset2);
        System.out.println("Set 1 equals sub set ? " + mySet1.equals(subset));
        mySet1.addAll(mySet2);
        System.out.println("Union of Set1 and Set2: " + mySet1);
        LinkedSortedSet<String> mySet3 = new LinkedSortedSet<>(String.CASE_INSENSITIVE_ORDER);
        mySet3.addAll(data.subList(3,8));
        System.out.println("My set 3: " + mySet3);
    }
}


```



